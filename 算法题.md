[TOC]
# 寻找最小正整数
要求：时间复杂度O(n)，空间复杂度不限：
给定一个未排序的，不重复的整数数组，
找出其中没有出现的最小的正整数。
例子：
[4,3,0] ： 1
[-1,2，7，1] : 3
> 解答
可以使用哈希表的方式解决这个问题。步骤如下：
1. 遍历数组，并将每个元素放入哈希表。
2. 从1开始遍历正整数，使用哈希表查找，找到第一个不存在的正整数。

Objective-C代码如下：
```Objective-C
- (NSInteger)findMissingPositive:(NSArray *)nums {
  // 初始化一个空的可变集合
  NSMutableSet *set = [NSMutableSet set];
  
  // 遍历数组，将每个元素放入集合中
  for (NSNumber *num in nums) {
    [set addObject:num];
  }
  
  // 从1开始遍历正整数
  NSInteger i = 1;
  while (YES) {
    // 如果集合中不存在当前数，返回当前数
    if (![set containsObject:@(i)]) {
      return i;
    }
    
    // 继续检查下一个数
    i++;
  }
}
```
在这段代码中，`findMissingPositive:`方法中创建了一个空的可变集合`set`用于存放数组`nums`中的元素。然后通过一个while循环从1开始遍历正整数，使用`[set containsObject:@(i)]`检查集合中是否存在当前的正整数`i`，如果不存在，即找到了没有出现的最小的正整数，返回当前的`i`即可。
注意这种方法的时间复杂度是O(n)，空间复杂度是O(n)，其中n是数组的数量。
# 求解树的最大宽度
给你一棵二叉树的根节点 root ，返回树的 最大宽度 。
树的 最大宽度 是所有层中最大的 宽度 。
每一层的 宽度 被定义为该层最左和最右的非空节点（即，两个端点）之间的长度。将这个二叉树视作与满二叉树结构相同，两端点间会出现一些延伸到这一层的 null 节点，这些 null 节点也计入长度。
题目数据保证答案将会在  32 位 带符号整数范围内。
              1
       3             2
5        3     x       9
输入：root = [1,3,2,5,3,null,9]输出：4
解释：最大宽度出现在树的第 3 层，宽度为 4 (5,3,null,9) 。
>  解答
这个问题可以通过使用层序遍历（BFS）和节点编号的方式来解决。对于非空节点，都会有一个唯一的编号，定义根节点的编号为1。对于编号为i的节点，其左子节点的编号为2*i，右子节点的编号为2*i+1。在层序遍历的过程中，用一个数组保存每一层的最左和最右节点的编号，通过最右节点编号减去最左节点编号+1得到当前层的宽度，再从所有层中找出最大宽度即可。

下面是一个Objective-C的代码示例：
```Objective-C
@interface TreeNode : NSObject

@property (nonatomic, strong) NSNumber *val;
@property (nonatomic, strong) TreeNode *left;
@property (nonatomic, strong) TreeNode *right;

- (instancetype)initWithValue:(NSNumber *)value;

@end

@implementation TreeNode

- (instancetype)initWithValue:(NSNumber *)value {
    self = [super init];
    
    if (self) {
        self.val = value;
    }
    
    return self;
}

@end

- (NSInteger)widthOfBinaryTree:(TreeNode *)root {
    NSMutableArray<NSMutableArray<NSNumber *> *> *depthAndPos = [NSMutableArray array];            
    __block NSInteger maxWidth = 0;
    [self dfs:root depth:0 pos:0 depthAndPos:depthAndPos maxWidth:&maxWidth];
    return maxWidth;
}

- (void)dfs:(TreeNode *)node depth:(NSInteger)depth pos:(NSInteger)pos depthAndPos:(NSMutableArray<NSMutableArray<NSNumber *> *> *)depthAndPos maxWidth:(NSInteger *)maxWidth {
    if (!node) {
        return;
    }
    if (depth >= depthAndPos.count) {
        // 如果当前深度没有出现过，那么第一次出现的节点一定是最左节点，将其添加到数组中
        [depthAndPos addObject:@[@(pos)]];
    } else {
        // 如果当前深度已经出现过，那么更新当前深度最右节点的位置
        [depthAndPos[depth] addObject:@(pos)];
    }
    NSInteger curWidth = [depthAndPos[depth].lastObject integerValue] - [depthAndPos[depth].firstObject integerValue] + 1;
    *maxWidth = MAX(*maxWidth, curWidth);
    [self dfs:node.left depth:depth + 1 pos:2 * pos depthAndPos:depthAndPos maxWidth:maxWidth];
    [self dfs:node.right depth:depth + 1 pos:2 * pos + 1 depthAndPos:depthAndPos maxWidth:maxWidth];
}
```
在这段代码中，`widthOfBinaryTree:`方法是主函数，使用DFS进行遍历，`dfs:`方法用于对每一个节点进行操作。在DFS中，首先判断当前节点如果为空则直接返回，然后根据当前的深度和位置更新`depthAndPos`数组，计算当前深度的宽度，并更新最大宽度`maxWidth`。然后递归地对左子节点和右子节点进行操作。
在主函数`widthOfBinaryTree:`中，设置了一个可变数组`depthAndPos`来保存每一层的最左和最右节点的位置，还设置了一个变量`maxWidth`来保存最大宽度，最后返回`maxWidth`。
注意，这段代码的时间复杂度和空间复杂度都是O(n)，其中n是二叉树中节点的数量。

以下是将上述代码转为Swift的版本：
```Swift
class Solution {
    func widthOfBinaryTree(_ root: TreeNode?) -> Int {
        var depthAndPos: [[Int]] = []
        var maxWidth = 0
        dfs(root, 0, 0, &depthAndPos, &maxWidth)
        return maxWidth
    }
    
    func dfs(_ node: TreeNode?, _ depth: Int, _ pos: Int, _ depthAndPos: inout [[Int]], _ maxWidth: inout Int) {
        guard let node = node else {
            return
        }
        if depth >= depthAndPos.count {
            depthAndPos.append([pos])
        } else {
            depthAndPos[depth].append(pos)
        }
        let curWidth = depthAndPos[depth].last! - depthAndPos[depth].first! + 1
        maxWidth = max(maxWidth, curWidth)
        dfs(node.left, depth + 1, 2 * pos, &depthAndPos, &maxWidth)
        dfs(node.right, depth + 1, 2 * pos + 1, &depthAndPos, &maxWidth)
    }
}
```
在这段 Swift 代码中，我们不再使用 `NSMutableArray` 或 `NSNumber`，而是使用 Swift 的数组和整数类型。同时，由于 Swift 不支持指针传递，我们使用 inout 关键字来实现对 maxWidth 的修改。请注意，最初的调用 `dfs(root, 0, 0, &depthAndPos, &maxWidth)` 是在函数 `widthOfBinaryTree` 中发生的。

以下是使用C语言的实现，主要是使用BFS算法和队列来求解承载二叉树的最大宽度问题。  
这里的实现方法中，使用了一个数据结构（struct QueueNode）来捕获每个节点和其位置。
每次我们的BFS算法进入新的一层，我们都会记录该层的第一个节点（即出列的第一个节点），并将其索引设置为0。在一层的其余部分，并将该层的其余节点设置为其索引于第一个节点的相对索引。
在这个实现中左孩子节点的索引是 `2 * parent_index`，右孩子节点的索引是 `2 * parent_index + 1`。这样我们每个节点都有一个唯一的索引，并且在同一层中的宽度就变得非常容易计算（最后一个节点的索引 - 第一个节点的索引 + 1）。
PCR: 代码执行的时间复杂度是 O(N)，其中 N 是结点的数量。
```C
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
};

struct QueueNode {
    struct TreeNode* node;
    unsigned long pos;
};

struct Queue {
    struct QueueNode* nodes;
    int size;
};

int widthOfBinaryTree(struct TreeNode* root) {
    struct Queue q;
    q.nodes = (struct QueueNode*)malloc(2000 * sizeof(struct QueueNode));
    q.size = 0;

    q.nodes[q.size++] = (struct QueueNode) {root, 1};

    int maxWidth = 0;
    while(q.size > 0) {
        int levelSize = q.size;
        unsigned long left = q.nodes[0].pos;
        unsigned long right = q.nodes[levelSize - 1].pos;
        maxWidth = fmax(maxWidth, right - left + 1);

        for(int i = 0; i < levelSize; i++) {
            struct TreeNode* node = q.nodes[i].node;
            unsigned long pos = q.nodes[i].pos;
            if(node->left) {
                q.nodes[q.size++] = (struct QueueNode) {node->left, 2 * pos};
            }
            if(node->right) {
                q.nodes[q.size++] = (struct QueueNode) {node->right, 2 * pos + 1};
            }
        }
        memmove(q.nodes, q.nodes + levelSize, (q.size - levelSize) * sizeof(struct QueueNode));
        q.size -= levelSize;
    }
    free(q.nodes);
    return maxWidth;
}
```
这段代码首先创建了一个保存树节点的队列，然后定义了一个变量 `maxWidth` 来保存最大宽度。然后进入了一个while循环，直到队列为空。在每一次循环中，首先记录了当前层数的大小，然后通过队列中的第一个节点和最后一个节点的位置来计算出当前层的宽度，并更新 `maxWidth`。然后对当前层的所有节点，如果它们有子节点，就将它们放入队列的末尾。最后将队列的头部移动到下一层的第一个节点，这样就完成了一次BFS，直到所有的节点都被处理完，最后 `maxWidth` 就是二叉树的最大宽度了。

这个问题可以使用队列和二叉树节点的编号来解决。
二叉树节点的编号可以体现出树的深度和宽度信息。例如，对于一个二叉树节点，如果其编号为 i，那么其左孩子的编号为 2*i，右孩子的编号为 2*i+1。可以看出，父节点与左孩子和右孩子的编号差是固定的，因此我们可以通过编号来得知某个节点在哪一层，并且编号的差值就是这一层的宽度。
这里的广度优先遍历与一般的广度优先遍历不同的地方在于，我们需要将每一层的节点作为一个单位进行处理。在每一次遍历到的节点中，首先判断这个节点是否是首个节点，如果是的话将其编号存入当前层的最左和最右的节点编号中，如果不是，就更新最右的节点编号。我们每次都取最大值，因此最终可以得到最大宽度。
下面是对应的 C++ 代码:
```C++ []
class Solution {
public:
    int widthOfBinaryTree(TreeNode* root) {
        if (root == nullptr) return 0;
        int result = 0;
        queue<pair<TreeNode*, unsigned long long>> q;
        q.push(make_pair(root, 1)); // root node index is 1
        while (!q.empty())
        {
            int count = q.size();
            unsigned long long left = q.front().second, right = left; // initialize left & right index
            for(int i = 0; i < count; ++i)
            {
                auto node = q.front().first;
                right = q.front().second; // update right index
                q.pop();
                if (node->left) 
                    q.push(make_pair(node->left, right * 2));
                if (node->right) 
                    q.push(make_pair(node->right, right * 2 + 1));
            }
            result = max(static_cast<int>(right - left + 1), result); // update result
        }
        return result;
    }
};
```
注意，这段代码也考虑到了越界的情况，它利用了 unsigned long long 类型的编号。

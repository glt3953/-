# OC中weak修饰的弱引用变量设置为 nil的原理
在 Objective-C 中，使用 `weak` 修饰符声明的变量是弱引用，它们指向的对象不会增加引用计数。当指向的对象被释放或销毁时，弱引用会被自动设置为 `nil`。这个过程是由 Objective-C 运行时系统自动完成的，具体原理如下：

当一个对象被释放时，它会向 Objective-C 运行时系统发送一条 `dealloc` 消息。在这个消息处理过程中，运行时系统会遍历所有指向该对象的弱引用，并将其设置为 `nil`。这个过程是在对象的 `dealloc` 方法执行完毕之前进行的，因此在对象的 `dealloc` 方法中，它是可以访问到所有指向它的弱引用的。

需要注意的是，由于弱引用不会增加对象的引用计数，因此在设置弱引用为 `nil` 时不会对对象的引用计数产生任何影响。同时，由于弱引用是在对象释放后被设置为 `nil`，因此不能在对象的 `dealloc` 方法中访问弱引用，否则会导致访问已经被设置为 `nil` 的弱引用，进而引发程序崩溃或其他不可预期的行为。
# OC中KVO的原理
在 Objective-C 中，KVO（Key-Value Observing）是一种机制，它允许对象监听其他对象某个属性值的变化。KVO 的原理可以简单概括为：**当监听对象的某个属性发生变化时，被监听对象会自动向监听对象发送一条通知，告知属性值的变化情况。**
具体来说，KVO 的实现原理如下：
1. 在运行时动态地为被监听对象的指定属性创建一个派生类，并重写该属性的 setter 方法。这个派生类通常以被监听对象的类名为前缀，加上一些固定后缀来命名。
2. 当监听对象注册对被监听对象的某个属性的观察时，KVO 机制会在运行时将监听对象加入到被监听对象的观察者列表中。
3. 当被监听对象的某个属性发生变化时，被监听对象会自动在 setter 方法中调用 `willChangeValueForKey:` 和 `didChangeValueForKey:` 方法，通知 KVO 机制该属性的值即将发生变化和已经发生变化。
4. KVO 机制在接收到这些通知后，会自动触发监听对象的 `observeValueForKeyPath:ofObject:change:context:` 方法，告知监听对象该属性的变化情况。在这个方法中，监听对象可以通过传入的 `change` 参数来获取属性变化的具体细节，例如变化前后的值、变化类型等等。

需要注意的是，被监听对象必须是继承自 NSObject 的对象，并且被监听的属性必须是 Objective-C 属性（即使用 `@property` 声明的属性）。另外，在使用 KVO 时，需要手动调用 `removeObserver:forKeyPath:` 方法来取消观察，否则可能会引发内存泄漏或其他不可预期的问题。
## KVC（Key-Value Coding）详细介绍
Key-Value Coding (KVC)是一种通过字符串来访问和操作对象属性的机制，在Objective-C中使用频繁。它主要使用键（key）进行操作，键是用来引用对象特性的字符串。
### 使用 KVC 
1. 读取属性值
   不再使用更为熟悉的类似obj.property的方式来访问属性值，而是使用KVC提供的方法：
   ```
   NSString *name = [person valueForKey:@"name"];  //获取name属性值
   ```
2. 修改属性值 
   ```
   [person setValue:@"newName" forKey:@"name"];  //设置name属性值
   ```
### 注意事项 
1. 键必须是字符串 ——您传递给KVC的键必须是字符串，编译器无法对字符串键的有效性进行检查，因此它容易引发运行时错误。
2. 值的类型需要匹配 —— 您不能为一个整型属性设置一个字符串值，否则运行时将会抛出异常。
3. 键拼写错误 —— 如果键拼写错误，运行时将会抛出异常。
4. 不存在的键 —— 如果您试图访问或设置一个不存在的键，运行时将会抛出异常。

KVC提供了强大的动态和间接访问对象的功能，虽然这在某些情况下非常有用，但也需要十分小心，因为它绕过了编译时类型检查，因此更容易出错。
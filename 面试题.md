## 主队列同步
以下代码输出的日志是____。
```
+  (void)test  {
       dispatch_sync(dispatch_get_main_queue(),  ^{
               printf("1");
     });
     printf("2");
}
```
如果以上代码在主队列中调用，
这段代码会造成死锁，然后会崩溃，所以没有任何输出。
分析：
`dispatch_sync`函数是同步地将block追加到指定的队列中。即，`dispatch_sync `函数不返回，直到block追加到queue参数所指定的队列并且运行到结束为止。

当在主线程中调用这段代码时，由于主队列中正在运行这段代码，主队列的任务无法并行运行，所以被加入到主队列中的block需要等待这段代码运行的结束。而这段代码又需要等待block的运行结束，这就造成了相互等待，形成了死锁。

如果以上代码在非主线程（其他线程）中调用，那么它的输出是"1"和"2"。分析：因为 `dispatch_sync`是同步的， 任务会等到 block中任务完成后才会继续执行，所以先打印 "1"，然后再打印 "2"。
## CALayer
关于 iOS App 中 CALayer 描述正确的是？
A.CALayer 可以响应基本的点击事件
B.CAAnimation 使用 GPU，而 UIView animation 使用 CPU
C.CALayer 的 contents 只可以显示 CGImageRef
D.CALayer 之间没有层级关系，而 UIView 有
**解析：**
A. CALayer 不直接处理用户和事件，也即是不直接支持用户交互，所以选项 A 错误。
B. 其实对于动画效果，UIView animation 和 CAAnimation 在底层都是由 Core Animation 提供支持，它们都使用 GPU，所以选项 B 错误。
C. CALayer 的 contents 属性只支持 CGImageRef 类型，可以用于显示图片。也可以为空，表示不显示内容。正确的选项为 C。
D. CALayer 之间是有层级关系的，每一个 layer 对象都可能拥有一些子 layer，从而形成一个 layer 树。所以选项 D 错误。
## TCP
TCP协议建立联接需要____次握手，断开联接需要___次挥手。
A. 2
B. 3
C. 4
D. 5
**解析:**
TCP协议是面向连接的协议，需要经过“三次握手”才能建立连接，断开连接需要“四次挥手”。
## HTTPS加密过程
HTTPS的加密过程涉及了SSL(TLS)握手、证书验证和数据传输加密三个主要部分。以下是其详细的加密过程：
1. SSL(Tensor Layer Security)/TLS(Transport Layer Security)握手：
   当用户在浏览器中输入一个HTTPS网址，浏览器会向服务器发送客户端的SSL版本号、加密算法种类、生成的随机数等信息。服务器收到后，会返回一个确认信息，其中包括选择的加密算法、一个服务器生成的随机数、以及数字证书。
2. 证书验证：
   浏览器获得服务器的数字证书后，会对其进行验证。首先，验证证书的有效期、证书的域名是否与正在访问的域名一致。其次，验证证书的发布机构是否值得信任，也就是是否在浏览器内置的信任机构列表中。如果这些都没有问题，浏览器就会从证书中取出公钥。
3. 通过公钥生成预主秘钥：
   浏览器会生成一个新的随机数，这个随机数叫做预主秘钥。然后通过证书的公钥，对预主秘钥进行加密，再将加密后的预主秘钥发送给服务器。
4. 服务器解密预主秘钥：
   服务器接收到浏览器发来的加密过的预主秘钥后，通过自己的私钥对其进行解密，得到预主秘钥。
5. 生成Session秘钥：
   到这步时，浏览器和服务器双方都拥有了三个随机数：客户端的随机数、服务器的随机数和预主秘钥。然后双方分别使用这三个随机数，通过约定的加密算法生成同一个Session秘钥。
6. 数据传输加密：
   浏览器和服务器使用Session秘钥对数据进行对称加密，然后进行数据传输。收到数据的一方，也使用同样的Session密钥对数据进行解密。
   
以上就是HTTPS的详细加密过程。整个过程中，使用非对称加密（证书的公钥、私钥）确保预主秘钥的安全传输，使用对称加密（Session秘钥）保证数据传输的效率。相信在非对称加密的安全性和对称加密的高效性之间找到了一个很好的平衡。
## dispatch_barrier_async
下面可能的执行顺序结果：
 dispatch_queue_t concurrentQueue
  = dispatch_queue_create("my.queue", DISPATCH_QUEUE_CONCURRENT);
 dispatch_async(concurrentQueue, ^(){
         NSLog(@"dispatch-1");
     });
     dispatch_async(concurrentQueue, ^(){
         NSLog(@"dispatch-2");
     });
     dispatch_barrier_async(concurrentQueue, ^(){
         NSLog(@"dispatch-barrier"); 
     });
     dispatch_async(concurrentQueue, ^(){
         NSLog(@"dispatch-3");
     });
A.dispatch-1,dispatch-2,dispatch-barrier,dispatch-3
B.dispatch-2,dispatch-1,dispatch-barrier,dispatch-3
C.dispatch-barrier,dispatch-1,dispatch-2,dispatch-3
D.dispatch-3,dispatch-1,dispatch-2,dispatch-barrier
**解析：**
dispatch_barrier_async 是在 concurrent queue 中的一个关键步骤，它会等待前面的任务（本例中的dispatch-1和dispatch-2）全部执行完才会执行（dispatch-barrier）。在 dispatch_barrier_async 执行完成后，后面的任务（dispatch-3）才会继续执行。
由于 dispatch_async 是将任务添加至队列并立即返回，且任务是并发执行的，所以 dispatch-1 和 dispatch-2 的执行次序不定，可能是 dispatch-1 先执行，也可能是 dispatch-2 先执行。所以结果可能是 A 或 B ，但最终必须等到 dispatch-barrier 完成后，才能执行 dispatch-3。
## atomic、copy、strong
指出以下两种 property 的写法，分别可能造成什么隐患？
@property (copy) NSMutableArray * array1;
@property (atomic, strong) NSArray * array2;
**解析：**
1. @property (copy) NSMutableArray * array1;
   这种写法将 NSMutableArray 进行了 copy 操作，由于 copy 返回的是不可变类型的数组，但是我们声明的类型是 NSMutableArray 可变数组，所以这种情况下如果你试图向 array1 添加或者移除对象，会导致程序崩溃。
2. @property (atomic, strong) NSArray * array2;
   atomic 修饰的属性在多线程环境下访问是线程安全的，但这并不代表其他所有操作都是线程安全的。例如，依然有可能在读取 array2 时返回一个值，但在使用这个值之前，另一个线程修改了 array2 。即，这种写法不能保证 getter 和 setter 操作的完整性。且 atomic 的属性等待锁的过程会阻塞当前线程，可能会导致性能问题。
   这种写法的数据会在多线程环境下保证数据的线程安全，但这仅仅保证了 getter 和 setter 的线程安全，如果你在一个线程中获取了数组，并在多个线程中进行操作（如修改，添加，删除等），那么就可能会造成数据冲突和不一致的问题。
   此外，strong类别意味着属性定义的创建一个指向NSArray对象的强引用。如果你有一个可变数组，并将其设置为此属性，然后修改原来的可变数组，那么这个属性引用的数组的内容也会改变。可能会造成意料之外的结果。如果不希望外部改变内部的状态，应该使用copy关键字让属性持有的值在被设置的时候已经是一个完全独立的副本，防止改变底层的对象导致的属性值变化。
## dispatch_semaphore_t
以下代码执行结果：
```
dispatch_semaphore_t  signal  =  dispatch_semaphore_create(1);    //  信号量为1
       dispatch_time_t  overTime  =  dispatch_time(DISPATCH_TIME_NOW,  3  *  NSEC_PER_SEC);
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,  0),  ^{
               dispatch_semaphore_wait(signal,  overTime);    
               NSLog(@"需要线程同步的操作1  开始");
               sleep(2);
               NSLog(@"需要线程同步的操作1  结束");
               dispatch_semaphore_signal(signal);
       });
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,  0),  ^{
               sleep(1);
                 NSLog(@"线程同步的操作2  将要开始");
               dispatch_semaphore_wait(signal,  overTime);
               NSLog(@"需要线程同步的操作2    结束");
               dispatch_semaphore_signal(signal);
       });
```
**解析：**
首先，线程1被触发，由于它先获取到了信号量(semaphore)，因此执行 "需要线程同步的操作1 开始" ，然后线程睡眠2秒。
在此期间，1秒后线程2被触发，打印 "线程同步的操作2 将要开始"，之后尝试去获取信号量，但是发现信号量已经被线程1获取，因此线程2处于等待状态。
2秒后，线程1唤醒，打印 "需要线程同步的操作1 结束" ，并释放信号量。
这时线程2获取到信号量，打印 "需要线程同步的操作2 结束" ，之后释放信号量。
所以，整体的执行流程如下：
```
需要线程同步的操作1 开始
线程同步的操作2 将要开始
需要线程同步的操作1 结束
需要线程同步的操作2 结束
```
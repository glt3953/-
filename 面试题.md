## 主队列同步
以下代码输出的日志是____。
```
+  (void)test  {
       dispatch_sync(dispatch_get_main_queue(),  ^{
               printf("1");
     });
     printf("2");
}
```
如果以上代码在主队列中调用，
这段代码会造成死锁，然后会崩溃，所以没有任何输出。
分析：
`dispatch_sync`函数是同步地将block追加到指定的队列中。即，`dispatch_sync `函数不返回，直到block追加到queue参数所指定的队列并且运行到结束为止。

当在主线程中调用这段代码时，由于主队列中正在运行这段代码，主队列的任务无法并行运行，所以被加入到主队列中的block需要等待这段代码运行的结束。而这段代码又需要等待block的运行结束，这就造成了相互等待，形成了死锁。

如果以上代码在非主线程（其他线程）中调用，那么它的输出是"1"和"2"。分析：因为 `dispatch_sync`是同步的， 任务会等到 block中任务完成后才会继续执行，所以先打印 "1"，然后再打印 "2"。
## CALayer
关于 iOS App 中 CALayer 描述正确的是？
A.CALayer 可以响应基本的点击事件
B.CAAnimation 使用 GPU，而 UIView animation 使用 CPU
C.CALayer 的 contents 只可以显示 CGImageRef
D.CALayer 之间没有层级关系，而 UIView 有
**解析：**
A. CALayer 不直接处理用户和事件，也即是不直接支持用户交互，所以选项 A 错误。
B. 其实对于动画效果，UIView animation 和 CAAnimation 在底层都是由 Core Animation 提供支持，它们都使用 GPU，所以选项 B 错误。
C. CALayer 的 contents 属性只支持 CGImageRef 类型，可以用于显示图片。也可以为空，表示不显示内容。正确的选项为 C。
D. CALayer 之间是有层级关系的，每一个 layer 对象都可能拥有一些子 layer，从而形成一个 layer 树。所以选项 D 错误。
## TCP
TCP协议建立联接需要____次握手，断开联接需要___次挥手。
A. 2
B. 3
C. 4
D. 5
**解析:**
TCP协议是面向连接的协议，需要经过“三次握手”才能建立连接，断开连接需要“四次挥手”。
## HTTPS加密过程
HTTPS的加密过程涉及了SSL(TLS)握手、证书验证和数据传输加密三个主要部分。以下是其详细的加密过程：
1. SSL(Tensor Layer Security)/TLS(Transport Layer Security)握手：
   当用户在浏览器中输入一个HTTPS网址，浏览器会向服务器发送客户端的SSL版本号、加密算法种类、生成的随机数等信息。服务器收到后，会返回一个确认信息，其中包括选择的加密算法、一个服务器生成的随机数、以及数字证书。
2. 证书验证：
   浏览器获得服务器的数字证书后，会对其进行验证。首先，验证证书的有效期、证书的域名是否与正在访问的域名一致。其次，验证证书的发布机构是否值得信任，也就是是否在浏览器内置的信任机构列表中。如果这些都没有问题，浏览器就会从证书中取出公钥。
3. 通过公钥生成预主秘钥：
   浏览器会生成一个新的随机数，这个随机数叫做预主秘钥。然后通过证书的公钥，对预主秘钥进行加密，再将加密后的预主秘钥发送给服务器。
4. 服务器解密预主秘钥：
   服务器接收到浏览器发来的加密过的预主秘钥后，通过自己的私钥对其进行解密，得到预主秘钥。
5. 生成Session秘钥：
   到这步时，浏览器和服务器双方都拥有了三个随机数：客户端的随机数、服务器的随机数和预主秘钥。然后双方分别使用这三个随机数，通过约定的加密算法生成同一个Session秘钥。
6. 数据传输加密：
   浏览器和服务器使用Session秘钥对数据进行对称加密，然后进行数据传输。收到数据的一方，也使用同样的Session密钥对数据进行解密。
   
以上就是HTTPS的详细加密过程。整个过程中，使用非对称加密（证书的公钥、私钥）确保预主秘钥的安全传输，使用对称加密（Session秘钥）保证数据传输的效率。相信在非对称加密的安全性和对称加密的高效性之间找到了一个很好的平衡。
## dispatch_barrier_async
下面可能的执行顺序结果：
 dispatch_queue_t concurrentQueue
  = dispatch_queue_create("my.queue", DISPATCH_QUEUE_CONCURRENT);
 dispatch_async(concurrentQueue, ^(){
         NSLog(@"dispatch-1");
     });
     dispatch_async(concurrentQueue, ^(){
         NSLog(@"dispatch-2");
     });
     dispatch_barrier_async(concurrentQueue, ^(){
         NSLog(@"dispatch-barrier"); 
     });
     dispatch_async(concurrentQueue, ^(){
         NSLog(@"dispatch-3");
     });
A.dispatch-1,dispatch-2,dispatch-barrier,dispatch-3
B.dispatch-2,dispatch-1,dispatch-barrier,dispatch-3
C.dispatch-barrier,dispatch-1,dispatch-2,dispatch-3
D.dispatch-3,dispatch-1,dispatch-2,dispatch-barrier
**解析：**
dispatch_barrier_async 是在 concurrent queue 中的一个关键步骤，它会等待前面的任务（本例中的dispatch-1和dispatch-2）全部执行完才会执行（dispatch-barrier）。在 dispatch_barrier_async 执行完成后，后面的任务（dispatch-3）才会继续执行。
由于 dispatch_async 是将任务添加至队列并立即返回，且任务是并发执行的，所以 dispatch-1 和 dispatch-2 的执行次序不定，可能是 dispatch-1 先执行，也可能是 dispatch-2 先执行。所以结果可能是 A 或 B ，但最终必须等到 dispatch-barrier 完成后，才能执行 dispatch-3。
## atomic、copy、strong
指出以下两种 property 的写法，分别可能造成什么隐患？
@property (copy) NSMutableArray * array1;
@property (atomic, strong) NSArray * array2;
**解析：**
1. @property (copy) NSMutableArray * array1;
   这种写法将 NSMutableArray 进行了 copy 操作，由于 copy 返回的是不可变类型的数组，但是我们声明的类型是 NSMutableArray 可变数组，所以这种情况下如果你试图向 array1 添加或者移除对象，会导致程序崩溃。
2. @property (atomic, strong) NSArray * array2;
   atomic 修饰的属性在多线程环境下访问是线程安全的，但这并不代表其他所有操作都是线程安全的。例如，依然有可能在读取 array2 时返回一个值，但在使用这个值之前，另一个线程修改了 array2 。即，这种写法不能保证 getter 和 setter 操作的完整性。且 atomic 的属性等待锁的过程会阻塞当前线程，可能会导致性能问题。
   这种写法的数据会在多线程环境下保证数据的线程安全，但这仅仅保证了 getter 和 setter 的线程安全，如果你在一个线程中获取了数组，并在多个线程中进行操作（如修改，添加，删除等），那么就可能会造成数据冲突和不一致的问题。
   此外，strong类别意味着属性定义的创建一个指向NSArray对象的强引用。如果你有一个可变数组，并将其设置为此属性，然后修改原来的可变数组，那么这个属性引用的数组的内容也会改变。可能会造成意料之外的结果。如果不希望外部改变内部的状态，应该使用copy关键字让属性持有的值在被设置的时候已经是一个完全独立的副本，防止改变底层的对象导致的属性值变化。
## dispatch_semaphore_t
以下代码执行结果：
```
dispatch_semaphore_t  signal  =  dispatch_semaphore_create(1);    //  信号量为1
       dispatch_time_t  overTime  =  dispatch_time(DISPATCH_TIME_NOW,  3  *  NSEC_PER_SEC);
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,  0),  ^{
               dispatch_semaphore_wait(signal,  overTime);    
               NSLog(@"需要线程同步的操作1  开始");
               sleep(2);
               NSLog(@"需要线程同步的操作1  结束");
               dispatch_semaphore_signal(signal);
       });
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,  0),  ^{
               sleep(1);
                 NSLog(@"线程同步的操作2  将要开始");
               dispatch_semaphore_wait(signal,  overTime);
               NSLog(@"需要线程同步的操作2    结束");
               dispatch_semaphore_signal(signal);
       });
```
**解析：**
首先，线程1被触发，由于它先获取到了信号量(semaphore)，因此执行 "需要线程同步的操作1 开始" ，然后线程睡眠2秒。
在此期间，1秒后线程2被触发，打印 "线程同步的操作2 将要开始"，之后尝试去获取信号量，但是发现信号量已经被线程1获取，因此线程2处于等待状态。
2秒后，线程1唤醒，打印 "需要线程同步的操作1 结束" ，并释放信号量。
这时线程2获取到信号量，打印 "需要线程同步的操作2 结束" ，之后释放信号量。
所以，整体的执行流程如下：
```
需要线程同步的操作1 开始
线程同步的操作2 将要开始
需要线程同步的操作1 结束
需要线程同步的操作2 结束
```
## 列表快速滑动性能优化
1. cell重用：使用dequeReusableCellWithIdentifier方法实现cell的重用，减少内存的消耗。
2. 减少复杂的布局和透明的子视图：避免在cell中使用过多的子视图和复杂的层级结构，尽量简化布局，更不要使用透明的视图，这会增加渲染的复杂度。
3. 异步加载图片： 对于cell中的图片，一般我们选择在子线程中进行下载和解码，然后回到主线程进行展现，减少主线程的工作量。
4. 按需加载：可见的cell才进行加载，不可见的cell则可以忽视不加载。
5. 避免在cellForRowAtIndexPath中进行大量的计算操作，把可以预先计算好的高度和数据在viewDidLoad的时候先计算好，在需要的时候直接使用。
6. 使用适当的缓存机制，如对图片进行缓存，使得在滚动时可以直接加载图片而不是重新下载。
7. 如果cell中的元素较多，可以考虑使用UIStackView，由系统自动管理视图的排列和ui性能的优化，提升性能。
## 离屏渲染
离屏渲染主要出现在以下几个场景：
1. 具有圆角（cornerRadius）的视图，尤其是涉及到图片视图（UIImageView）或者是文本框（UITextView）的情况。对于长列表来说，列表中的每一项都可能需要渲染圆角，因此很可能触发离屏渲染。
2. 视图有阴影（shadow）效果也会触发离屏渲染。
3. 视图的层级关系中，如果有遮罩（mask）效果，也会触发离屏渲染。
4. 使用了图层蒙版（layer.mask）
5. 使用了组透明（shouldRasterize): 当你把 UIView 或者 CALayer 的 shouldRasterize 属性设置为 true 的时候。
6. 使用一些 Core Graphics 绘制的一些阴影或渐变效果。

离屏渲染不仅仅会增加CPU和GPU的压力，还会增加应用的内存消耗，所以在实际开发中应尽量避免触发离屏渲染，以优化应用性能。
## SDWebImage处理两个UIImageView同时请求一份url
SDWebImage是通过一个名为SDWebImageDownloader的单例来实现多个UIImageView共享同时请求一份URL图的功能。

在 SDWebImageDownloader 中，SDWebImage 通过一个 URL 作为唯一 key，将对应的多个 completion block 存储到一个 NSMutableDictionary 中。

当某个 UIImageView 请求下载图片时（通过调用SDWebImageManager的loadImageWithURL:options:progress:completed:方法），SDWebImage 首先会检查这个 URL 是否已经存在于 NSMutableDictionary 中，如果不存在，就会为这个 URL 创建一个新的下载 operation 添加到下载队列中，并且将这个 UIImageView 的 completion block 添加到 NSMutableDictionary 对应 url 的数组中。

如果这个 URL 已经存在于 NSMutableDictionary 中，就说明这个 URL 的图片已经在下载中，那么 SDWebImage 仅仅会将这个 UIImageView 的 completion block 直接添加到 NSMutableDictionary 对应url的数组中。

当图片下载完成后，SDWebImageDownloader 会通过 URL 这个唯一的 key，找到 NSMutableDictionary 中对应的所有 completion block，然后逐一调用 completion block，将下载好的图片传递给每一个 UIImageView。完成此步骤后，会将这个URL key从NSMutableDictionary中移除。

这样，虽然有多个 UIImageView 请求同一份 URL 图片，但是实际上只发出一次网络请求，多个 UIImageView 共享同一份下载的图片，避免了不必要的网络请求和内存浪费。

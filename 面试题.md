## 主队列同步
以下代码输出的日志是____。
```
+  (void)test  {
       dispatch_sync(dispatch_get_main_queue(),  ^{
               printf("1");
     });
     printf("2");
}
```
如果以上代码在主队列中调用，这段代码会造成死锁，然后会崩溃，所以没有任何输出。
分析：
`dispatch_sync`函数是同步地将block追加到指定的队列中。即，`dispatch_sync `函数不返回，直到block追加到queue参数所指定的队列并且运行到结束为止。

当在主线程中调用这段代码时，由于主队列中正在运行这段代码，主队列的任务无法并行运行，所以被加入到主队列中的block需要等待这段代码运行的结束。而这段代码又需要等待block的运行结束，这就造成了相互等待，形成了死锁。

如果以上代码在非主线程（其他线程）中调用，那么它的输出是"1"和"2"。分析：因为 `dispatch_sync`是同步的， 任务会等到 block中任务完成后才会继续执行，所以先打印 "1"，然后再打印 "2"。
## CALayer
关于 iOS App 中 CALayer 描述正确的是？
A.CALayer 可以响应基本的点击事件
B.CAAnimation 使用 GPU，而 UIView animation 使用 CPU
C.CALayer 的 contents 只可以显示 CGImageRef
D.CALayer 之间没有层级关系，而 UIView 有
**解析：**
A. CALayer 不直接处理用户和事件，也即是不直接支持用户交互，所以选项 A 错误。
B. 其实对于动画效果，UIView animation 和 CAAnimation 在底层都是由 Core Animation 提供支持，它们都使用 GPU，所以选项 B 错误。
C. CALayer 的 contents 属性只支持 CGImageRef 类型，可以用于显示图片。也可以为空，表示不显示内容。正确的选项为 C。
D. CALayer 之间是有层级关系的，每一个 layer 对象都可能拥有一些子 layer，从而形成一个 layer 树。所以选项 D 错误。
## TCP
TCP协议建立联接需要____次握手，断开联接需要___次挥手。
A. 2
B. 3
C. 4
D. 5
**解析：**
TCP协议是面向连接的协议，需要经过“三次握手”才能建立连接，断开连接需要“四次挥手”。
**详细流程：**
TCP 协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。在 TCP/IP 协议中，TCP协议提供的是一种稳定而可靠的服务，它包括了数据传输过程中可能出现的所有异常情况。下面我来详细说明一下它的“三次握手”建立连接以及断开连接的“四次挥手”过程。
“三次握手”建立连接过程：
1. 首先，客户端会发送一个建立连接请求，这个请求中包含一个随机生成的序列号 A。这就是“握手”的第一次。
2. 然后，服务器接收到这个请求后，会发送一个应答，这个应答中包含了服务器随机生成的序列号 B，并且也包含了对客户端第一次握手的确认信息，即 A+1。这就是“握手”的第二次。
3. 最后，客户端再次发送一个应答，其中包含了对服务器第二次握手的确认信息，即 B+1。当服务器接收到这个应答后，就完成了序列号的交换，也就是连接的建立。这是“握手”的第三次。

"四次挥手"断开连接过程：
1. 当数据传输完成后，客户端发送一个 FIN 数据包给服务端，请求关闭连接，这是“挥手”的第一次。
2. 服务端接收到这个 FIN 后，回送一个 ACK 应答包，确认收到了断开连接的请求，但是注意，此时并不会立即关闭连接，只是告诉客户端，“你的请求我收到了”。这是“挥手”的第二次。
3. 等服务端所有的数据都发送完成后，也会向客户端发送一个 FIN 数据包，请求关闭连接，这是“挥手”的第三次。
4. 客户端接收到服务端的 FIN 请求后，还需要回送一个 ACK 应答包，确认已经允许断开连接，一旦确认无误，便会正式切断连接，这是“挥手”的第四次。 

在这个过程中，为何需要“三次握手”而非两次或者四次呢？这主要是为了防止已过期的连接请求到达服务器，以及能够进行双方的序列号同步。而“四次挥手”之所以比“三次握手”多一个步骤，则是因为服务端在接受到断开连接的请求后，仍需要发送完毕所有未发送结束的数据包，必须保证客户端接收到所有数据后才能执行断开连接的操作。
**备注：**
“已过期的连接请求”指的是在网络中存在一些滞留的、过时的请求，这些请求在网络中被延迟了相当长的时间，久到在建立连接的两台主机上看来，连接请求已经完成或者已经超时。当这个过期请求最后到达服务器时，会导致不必要的错误。
举个例子：
1. 客户端发起连接请求，由于网络延迟或者网络环境异常，这个请求包并没有立刻被服务器接收，而是在网络中滞留。
2. 时间久了，客户端认为请求已经超时或者失败，于是放弃这次连接，过一会儿又发起一个新的连接。
3. 服务器先是接收到新的连接请求，建立了连接。但是网络延迟的旧的连接请求这时才到达服务器，服务器误认为是客户端想建立新的连接，于是再次为客户端建立了连接。

以上情况就会导致两个连接被建立，但实际上客户端只需要一个连, 这样会造成资源浪费和错误。因此，“三次握手”的设计，能防止这种"已过期的连接请求"，确保了连接的正确性。
## HTTPS加密过程
HTTPS的加密过程涉及了SSL(TLS)握手、证书验证和数据传输加密三个主要部分。以下是其详细的加密过程：
1. SSL(Tensor Layer Security)/TLS(Transport Layer Security)握手：
   当用户在浏览器中输入一个HTTPS网址，浏览器会向服务器发送客户端的SSL版本号、加密算法种类、生成的随机数等信息。服务器收到后，会返回一个确认信息，其中包括选择的加密算法、一个服务器生成的随机数、以及数字证书。
2. 证书验证：
   浏览器获得服务器的数字证书后，会对其进行验证。首先，验证证书的有效期、证书的域名是否与正在访问的域名一致。其次，验证证书的发布机构是否值得信任，也就是是否在浏览器内置的信任机构列表中。如果这些都没有问题，浏览器就会从证书中取出公钥。
3. 通过公钥生成预主秘钥：
   浏览器会生成一个新的随机数，这个随机数叫做预主秘钥。然后通过证书的公钥，对预主秘钥进行加密，再将加密后的预主秘钥发送给服务器。
4. 服务器解密预主秘钥：
   服务器接收到浏览器发来的加密过的预主秘钥后，通过自己的私钥对其进行解密，得到预主秘钥。
5. 生成Session秘钥：
   到这步时，浏览器和服务器双方都拥有了三个随机数：客户端的随机数、服务器的随机数和预主秘钥。然后双方分别使用这三个随机数，通过约定的加密算法生成同一个Session秘钥。
6. 数据传输加密：
   浏览器和服务器使用Session秘钥对数据进行对称加密，然后进行数据传输。收到数据的一方，也使用同样的Session密钥对数据进行解密。
   
以上就是HTTPS的详细加密过程。整个过程中，使用非对称加密（证书的公钥、私钥）确保预主秘钥的安全传输，使用对称加密（Session秘钥）保证数据传输的效率。相信在非对称加密的安全性和对称加密的高效性之间找到了一个很好的平衡。
## dispatch_barrier_async
下面可能的执行顺序结果：
 dispatch_queue_t concurrentQueue
  = dispatch_queue_create("my.queue", DISPATCH_QUEUE_CONCURRENT);
 dispatch_async(concurrentQueue, ^(){
         NSLog(@"dispatch-1");
     });
     dispatch_async(concurrentQueue, ^(){
         NSLog(@"dispatch-2");
     });
     dispatch_barrier_async(concurrentQueue, ^(){
         NSLog(@"dispatch-barrier"); 
     });
     dispatch_async(concurrentQueue, ^(){
         NSLog(@"dispatch-3");
     });
A.dispatch-1,dispatch-2,dispatch-barrier,dispatch-3
B.dispatch-2,dispatch-1,dispatch-barrier,dispatch-3
C.dispatch-barrier,dispatch-1,dispatch-2,dispatch-3
D.dispatch-3,dispatch-1,dispatch-2,dispatch-barrier
**解析：**
dispatch_barrier_async 是在 concurrent queue 中的一个关键步骤，它会等待前面的任务（本例中的dispatch-1和dispatch-2）全部执行完才会执行（dispatch-barrier）。在 dispatch_barrier_async 执行完成后，后面的任务（dispatch-3）才会继续执行。
由于 dispatch_async 是将任务添加至队列并立即返回，且任务是并发执行的，所以 dispatch-1 和 dispatch-2 的执行次序不定，可能是 dispatch-1 先执行，也可能是 dispatch-2 先执行。所以结果可能是 A 或 B ，但最终必须等到 dispatch-barrier 完成后，才能执行 dispatch-3。
## atomic、copy、strong
指出以下两种 property 的写法，分别可能造成什么隐患？
@property (copy) NSMutableArray * array1;
@property (atomic, strong) NSArray * array2;
**解析：**
1. @property (copy) NSMutableArray * array1;
   这种写法将 NSMutableArray 进行了 copy 操作，由于 copy 返回的是不可变类型的数组，但是我们声明的类型是 NSMutableArray 可变数组，所以这种情况下如果你试图向 array1 添加或者移除对象，会导致程序崩溃。
2. @property (atomic, strong) NSArray * array2;
   atomic 修饰的属性在多线程环境下访问是线程安全的，但这并不代表其他所有操作都是线程安全的。例如，依然有可能在读取 array2 时返回一个值，但在使用这个值之前，另一个线程修改了 array2 。即，这种写法不能保证 getter 和 setter 操作的完整性。且 atomic 的属性等待锁的过程会阻塞当前线程，可能会导致性能问题。
   这种写法的数据会在多线程环境下保证数据的线程安全，但这仅仅保证了 getter 和 setter 的线程安全，如果你在一个线程中获取了数组，并在多个线程中进行操作（如修改，添加，删除等），那么就可能会造成数据冲突和不一致的问题。
   此外，strong类别意味着属性定义的创建一个指向NSArray对象的强引用。如果你有一个可变数组，并将其设置为此属性，然后修改原来的可变数组，那么这个属性引用的数组的内容也会改变。可能会造成意料之外的结果。如果不希望外部改变内部的状态，应该使用copy关键字让属性持有的值在被设置的时候已经是一个完全独立的副本，防止改变底层的对象导致的属性值变化。
## 深拷贝和浅拷贝
在iOS开发中，深拷贝和浅拷贝是两种不同的对象复制方式，它们在复制过程中对内存的处理方式有所不同。
**浅拷贝（Shallow Copy）：**
浅拷贝是指对内存地址的复制，使得目标对象指针和源对象指向同一片内存空间。当内存销毁的时候，指向这片内存的几个指针需要重新定义才可以使用，否则会成为野指针。浅拷贝相当于拷贝了指向原来对象的指针，使原对象的引用计数+1，可以理解为创建了一个指向原对象的新指针而已，并没有创建一个全新的对象。
**深拷贝（Deep Copy）：**
深拷贝是指拷贝对象的具体内容，而内存地址是自主分配的。拷贝结束之后，两个对象虽然存的值是相同的，但是内存地址不一样，两个对象也互不影响，互不干涉。深拷贝相当于拷贝出和原来仅仅是值一样，但是内存地址完全不一样的新的对象，创建后和原对象没有任何关系。深拷贝就是内容拷贝，而浅拷贝就是指针拷贝。
总结来说，浅拷贝和深拷贝的主要区别在于是否开启新的内存地址。如果开启新的内存地址，则为深拷贝；如果复用原有内存地址，则为浅拷贝。
## dispatch_semaphore_t
以下代码执行结果：
```
dispatch_semaphore_t  signal  =  dispatch_semaphore_create(1);    //  信号量为1
       dispatch_time_t  overTime  =  dispatch_time(DISPATCH_TIME_NOW,  3  *  NSEC_PER_SEC);
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,  0),  ^{
               dispatch_semaphore_wait(signal,  overTime);    
               NSLog(@"需要线程同步的操作1  开始");
               sleep(2);
               NSLog(@"需要线程同步的操作1  结束");
               dispatch_semaphore_signal(signal);
       });
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,  0),  ^{
               sleep(1);
                 NSLog(@"线程同步的操作2  将要开始");
               dispatch_semaphore_wait(signal,  overTime);
               NSLog(@"需要线程同步的操作2    结束");
               dispatch_semaphore_signal(signal);
       });
```
**解析：**
首先，线程1被触发，由于它先获取到了信号量(semaphore)，因此执行 "需要线程同步的操作1 开始" ，然后线程睡眠2秒。
在此期间，1秒后线程2被触发，打印 "线程同步的操作2 将要开始"，之后尝试去获取信号量，但是发现信号量已经被线程1获取，因此线程2处于等待状态。
2秒后，线程1唤醒，打印 "需要线程同步的操作1 结束" ，并释放信号量。
这时线程2获取到信号量，打印 "需要线程同步的操作2 结束" ，之后释放信号量。
所以，整体的执行流程如下：
```
需要线程同步的操作1 开始
线程同步的操作2 将要开始
需要线程同步的操作1 结束
需要线程同步的操作2 结束
```
## 列表快速滑动性能优化
1. cell重用：使用dequeReusableCellWithIdentifier方法实现cell的重用，减少内存的消耗。
2. 减少复杂的布局和透明的子视图：避免在cell中使用过多的子视图和复杂的层级结构，尽量简化布局，更不要使用透明的视图，这会增加渲染的复杂度。
3. 异步加载图片： 对于cell中的图片，一般我们选择在子线程中进行下载和解码，然后回到主线程进行展现，减少主线程的工作量。
4. 按需加载：可见的cell才进行加载，不可见的cell则可以忽视不加载。
5. 避免在cellForRowAtIndexPath中进行大量的计算操作，把可以预先计算好的高度和数据在viewDidLoad的时候先计算好，在需要的时候直接使用。
6. 使用适当的缓存机制，如对图片进行缓存，使得在滚动时可以直接加载图片而不是重新下载。
7. 如果cell中的元素较多，可以考虑使用UIStackView，由系统自动管理视图的排列和ui性能的优化，提升性能。
## 离屏渲染
离屏渲染主要出现在以下几个场景：
1. 具有圆角（cornerRadius）的视图，尤其是涉及到图片视图（UIImageView）或者是文本框（UITextView）的情况。对于长列表来说，列表中的每一项都可能需要渲染圆角，因此很可能触发离屏渲染。
2. 视图有阴影（shadow）效果也会触发离屏渲染。
3. 视图的层级关系中，如果有遮罩（mask）效果，也会触发离屏渲染。
4. 使用了图层蒙版（layer.mask）
5. 使用了组透明（shouldRasterize): 当你把 UIView 或者 CALayer 的 shouldRasterize 属性设置为 true 的时候。
6. 使用一些 Core Graphics 绘制的一些阴影或渐变效果。

离屏渲染不仅仅会增加CPU和GPU的压力，还会增加应用的内存消耗，所以在实际开发中应尽量避免触发离屏渲染，以优化应用性能。
## SDWebImage处理两个UIImageView同时请求一份url
SDWebImage是通过一个名为SDWebImageDownloader的单例来实现多个UIImageView共享同时请求一份URL图的功能。

在 SDWebImageDownloader 中，SDWebImage 通过一个 URL 作为唯一 key，将对应的多个 completion block 存储到一个 NSMutableDictionary 中。

当某个 UIImageView 请求下载图片时（通过调用SDWebImageManager的loadImageWithURL:options:progress:completed:方法），SDWebImage 首先会检查这个 URL 是否已经存在于 NSMutableDictionary 中，如果不存在，就会为这个 URL 创建一个新的下载 operation 添加到下载队列中，并且将这个 UIImageView 的 completion block 添加到 NSMutableDictionary 对应 url 的数组中。

如果这个 URL 已经存在于 NSMutableDictionary 中，就说明这个 URL 的图片已经在下载中，那么 SDWebImage 仅仅会将这个 UIImageView 的 completion block 直接添加到 NSMutableDictionary 对应url的数组中。

当图片下载完成后，SDWebImageDownloader 会通过 URL 这个唯一的 key，找到 NSMutableDictionary 中对应的所有 completion block，然后逐一调用 completion block，将下载好的图片传递给每一个 UIImageView。完成此步骤后，会将这个URL key从NSMutableDictionary中移除。

这样，虽然有多个 UIImageView 请求同一份 URL 图片，但是实际上只发出一次网络请求，多个 UIImageView 共享同一份下载的图片，避免了不必要的网络请求和内存浪费。

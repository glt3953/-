# 本地持久化方案及动态部署
https://casatwy.com/iosying-yong-jia-gou-tan-ben-di-chi-jiu-hua-fang-an-ji-dong-tai-bu-shu.html
## 前言
https://github.com/casatwy/CTPersistance
https://github.com/casatwy/CTJSBridge
我在移动端这边做持久化方案设计的时候，考虑更多的是方案的可维护和可拓展，然后在此基础上才是性能调优。
持久化方案对整个App架构的影响和网络层方案对整个架构的影响类似，一般都是导致整个项目耦合度高的罪魁祸首。而我也是一如既往的**去Model化**的实践者，在持久层去Model化的过程中，我引入了**Virtual Record**的设计。
## 根据需求决定持久化方案
在有需要持久化需求的时候，我们有非常多的方案可供选择：**NSUserDefault、KeyChain、File，以及基于数据库的无数子方案**。因此，当有需要持久化的需求的时候，我们首先考虑的是应该采用什么手段去进行持久化。
### NSUserDefault
一般来说，小规模数据，弱业务相关数据，都可以放到NSUserDefault里面，内容比较多的数据，强业务相关的数据就不太适合NSUserDefault了。
### Keychain
Keychain是苹果提供的带有可逆加密的存储机制，普遍用在各种存密码的需求上。另外，由于App卸载只要系统不重装，Keychain中的数据依旧能够得到保留，以及可被iCloud同步的特性，大家都会在这里存储用户唯一标识串。所以有需要加密、需要存iCloud的敏感小数据，一般都会放在Keychain。
### 文件存储
文件存储包括了**Plist、archive、Stream**等方式，一般结构化的数据或者需要方便查询的数据，都会以Plist的方式去持久化。Archive方式适合存储平时不太经常使用但很大量的数据，或者读取之后希望直接对象化的数据，因为Archive会将对象及其对象关系序列化，以至于读取数据的时候需要Decode很花时间，Decode的过程可以是解压，也可以是对象化，这个可以根据具体NSCoding中的实现来决定。Stream就是一般的文件存储了，一般用来存存图片啊啥的，适用于比较经常使用，然而数据量又不算非常大的那种。
### 数据库存储
数据库存储的话，花样就比较多了。苹果自带了一个Core Data，当然业界也有无数替代方案可选，不过真正用在iOS领域的除了Core Data外，就是FMDB比较多了。数据库方案主要是为了便于增删改查，当数据有状态和类别的时候最好还是采用数据库方案比较好，而且尤其是当这些状态和类别都是强业务相关的时候，就更加要采用数据库方案了。因为你不可能通过文件系统遍历文件去甄别你需要获取的属于某个状态或类别的数据，这么做成本就太大了。当然，特别大量的数据也不适合直接存储数据库，比如图片或者文章这样的数据，一般来说，都是数据库存一个文件名，然后这个文件名指向的是某个图片或者文章的文件。如果真的要做全文索引这种需求，建议最好还是挂个API丢到服务端去做。
**WCDB（WeChat DataBase）** 是微信官方的移动端数据库组件，致力于提供一个高效、易用、完整的移动端存储方案。https://github.com/Tencent/wcdb 它包含三个模块：
* WCDB-iOS/Mac
* WCDB-Android
* 数据库损坏修复工具WCDBRepair


微信移动端数据库组件WCDB系列
https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=2649286538&idx=1&sn=d11de2d87539a64e991e916013b0f729&chksm=8334c308b4434a1e5670fb68dc087cf34fe91e79bbfc64dbbf092424fd0cd3b28023c67b29ca&scene=21#wechat_redirect
## 持久层实现时要注意的隔离
在设计持久层架构的时候，我们要关注以下几个方面的隔离：
### 持久层与业务层的隔离
* Data Model
Data Model这个术语针对的问题领域是业务数据的建模，以及代码中这一数据模型的表征方式。两者相辅相承：因为业务数据的建模方案以及业务本身特点，而最终决定了数据的表征方式。同样操作一批数据，你的数据建模方案基本都是细化业务问题之后，抽象得出一个逻辑上的实体。在实现这个业务时，你可以选择不同的表征方式来表征这个逻辑上的实体，比如**字节流(TCP包等)，字符串流(JSON、XML等)，对象流**。对象流又分**通用数据对象(NSDictionary等)，业务数据对象(HomeCellModel等)**。
前面已经遍历了所有的Data Model的形式。在习惯上，当我们讨论Model化时，都是单指对象流中的业务数据对象这一种。然而去Model化就是指：**更多地使用通用数据对象去表征数据，业务数据对象不会在设计时被优先考虑的一种设计倾向。这里的通用数据对象可以在某种程度上理解为范型。**
* Model Layer
Model Layer描述的问题领域是如何对数据进行**增删改查(CURD, Create Update Read Delete)**，和相关业务处理。一般来说如果在Model Layer中采用瘦Model的设计思路的话，就差不多到CURD为止了。胖Model还会关心如何为需要数据的上层提供除了增删改查以外的服务，并为他们提供相应的解决方案。例如**缓存、数据同步、弱业务处理**等。

我更加倾向于去Model化的设计，**在网络层，我设计了reformer来实现去Model化。在持久层，我设计了Virtual Record来实现去Model化。**
因为具体的Model是一种很容易引入耦合的做法，在尽可能弱化Model概念的同时，就能够为引入业务和对接业务提供充分的空间。同时，也能**通过去Model的设计达到区分强弱业务的目的**，这在将来的代码迁移和维护中，是至关重要的。很多设计不好的架构，就在于架构师并没有认识到区分强弱业务的重要性，所以就导致架构腐化的速度很快，越来越难维护。
所以说回来，持久层与业务层之间的隔离，是通过强弱业务的隔离达到的。而Virtual Record正是因为这种去Model化的设计，从而达到了强弱业务的隔离，进而做到持久层与业务层之间既隔离同时又能交互的平衡。
### 数据库读写隔离
在网站的架构中，对数据库进行读写分离主要是为了提高响应速度。在iOS应用架构中，对持久层进行读写隔离的设计主要是为了提高代码的可维护性。
在这里我们**所谓的读写隔离并不是指将数据的读操作和写操作做隔离。而是以某一条界限为准，在这个界限以外的所有数据模型，都是不可写不可修改，或者修改属性的行为不影响数据库中的数据，在这个界限以内的数据是可写可修改的**。一般来说我们在设计时划分的这个界限会和持久层与业务层之间的界限保持一致，也就是业务层从持久层拿到数据之后，都不可写不可修改，或业务层针对这一数据模型的写操作、修改操作都对数据库文件中的内容不产生作用。只有持久层中的操作才能够对数据库文件中的内容产生作用。
在苹果官方提供的持久层方案Core Data的架构设计中，并没有针对读写作出隔离，数据的结果都是以NSManagedObject扔出。所以只要业务工程师稍微一不小心动一下某个属性，NSManagedObjectContext在save的时候就会把这个修改给存进去了。另外，当我们需要对所有的增删改查操作做AOP的切片时，Core Data技术栈的实现就会非常复杂。整体上看，我觉得Core Data相对大部分需求而言是过度设计了。
读写隔离还能够便于加入AOP切点，因为针对数据库的写操作被隔离到一个固定的地方，加AOP时就很容易在正确的地方放入切片。
### 多线程控制导致的隔离
* Core Data
Core Data要求在多线程场景下，为异步操作再生成一个NSManagedObjectContext，然后设置它的ConcurrencyType为NSPrivateQueueConcurrencyType，最后把这个Context的parentContext设为Main线程下的Context。这相比于使用原始的SQLite去做多线程要轻松许多。只不过要注意的是，如果要传递NSManagedObject的时候，不能直接传这个对象的指针，要传NSManagedObjectID。这属于多线程环境下对象传递的隔离，在进行架构设计的时候需要注意。
* SQLite
纯SQLite其实对于多线程倒是直接支持，SQLite库提供了三种方式：**Single Thread，Multi Thread，Serialized**。
Single Thread模式不是线程安全的，不提供任何同步机制。Multi Thread模式要求database connection不能在多线程中共享，其他的在使用上就没什么特殊限制了。Serialized模式顾名思义就是由一个串行队列来执行所有的操作，对于使用者来说除了响应速度会慢一些，基本上就没什么限制了。大多数情况下SQLite的默认模式是Serialized。
根据Core Data在多线程场景下的表现，我觉得Core Data在使用SQLite作为数据载体时，使用的应该就是Multi Thread模式。**SQLite在Multi Thread模式下使用的是读写锁，而且是针对整个数据库加锁，不是表锁也不是行锁**，这一点需要提醒各位架构师注意。如果对响应速度要求很高的话，建议开一个辅助数据库，把一个大的写入任务先写入辅助数据库，然后拆成几个小的写入任务见缝插针地隔一段时间往主数据库中写入一次，写完之后再把辅助数据库删掉。
不过从实际经验上看，本地App的持久化需求的读写操作一般都不会大，只要注意好几个点之后一般都不会影响用户体验。因此相比于Multi Thread模式，Serialized模式我认为是性价比比较高的一种选择，代码容易写容易维护，性能损失不大。
### 数据表达和数据操作的隔离
数据表达和数据操作的隔离是否能够做好，直接影响的是整个程序的可拓展性。
长久以来，我们都很习惯Active Record类型的数据操作和表达方式，例如这样：
![](assets/16790436441252.jpg)
或者这种：
![](assets/16790436606441.jpg)
简单说就是，让一个对象映射了一个数据库里的表，然后**针对这个对象做操作就等同于针对这个表以及这个对象所表达的数据做操作**。**这里有一个不好的地方就在于，这个Record既是数据库中数据表的映射，又是这个表中某一条数据的映射**。我见过很多框架(不仅限于iOS，包括Python, PHP等)都把这两者混在一起去处理。如果按照这种不恰当的方式来组织数据操作和数据表达，在胖Model的实践下会导致强弱业务难以区分从而造成非常大的困难。
强弱业务不能区分带来的最大困难在于代码复用和迁移，因为持久层中的强业务对View层业务的高耦合是无法避免的，然而**弱业务相对而言只对下层有耦合关系对上层并不存在耦合关系**，当我们做代码迁移或者复用时，往往希望复用的是弱业务而不是强业务，若此时强弱业务分不开，代码复用就无从谈起，迁移时就倍加困难。
另外，数据操作和数据表达混在一起会导致的问题在于：**客观情况下，数据在view层业务上的表达方式多种多样，有可能是个View，也有可能是个别的什么对象**。如果采用映射数据库表的数据对象去映射数据，那么这种多样性就会被限制，实际编码时每到使用数据的地方，就不得不多一层转换。
我认为之所以会产生这样不好的做法原因在于，对象对数据表的映射和对象对数据表达的映射结果非常相似，尤其是在表达Column时，他们几乎就是一模一样。在这里要**做好针对数据表或是针对数据的映射要做的区分的关键要点是：这个映射对象的操作着手点相对数据表而言，是对内还是对外操作**。如果是对内操作，那么这个操作范围就仅限于当前数据表，这些操作映射给数据表模型就比较合适。如果是对外操作，执行这些操作时有可能涉及其他的数据表，那么这些操作就不应该映射到数据表对象中。
因此实际操作中，我是**以数据表为单位去针对操作进行对象封装，然后再针对数据记录进行对象封装**。数据表中的操作都是针对记录的普通增删改查操作，都是弱业务逻辑。数据记录仅仅是数据的表达方式，这些操作最好交付给数据层分管强业务的对象去执行。
## 持久层与业务层的交互方式
![](assets/16790444987163.jpg)
持久层有专门负责对接View层模块或业务的**DataCenter**，它们之间通过**Record**来进行交互。DataCenter向上层提供业务友好的接口，这一般都是强业务：比如根据用户筛选条件返回符合要求的数据等。
然后DataCenter在这个接口里面调度各个**Table**，做一系列的业务逻辑，最终生成record对象，交付给View层业务。
DataCenter为了要完成View层交付的任务，会涉及**数据组装和跨表的数据操作**。数据组装因为View层要求的不同而不同，因此是强业务。跨表数据操作本质上就是各单表数据操作的组合，DataCenter负责调度这些单表数据操作从而获得想要的基础数据用于组装。那么，这时候单表的数据操作就属于弱业务，这些弱业务就由Table映射对象来完成。
Table对象通过**QueryCommand**来生成相应的SQL语句，并交付给数据库引擎去查询获得数据，然后交付给DataCenter。
### DataCenter 和 Virtual Record
DataCenter其实是一个业务对象，DataCenter是整个App中，持久层与业务层之间的胶水。它向业务层开放业务友好的接口，然后通过调度各个持久层弱业务逻辑和数据记录来完成强业务逻辑，并将生成的结果交付给业务层。由于DataCenter处在业务层和持久层之间，那么它执行业务逻辑所需要的载体，就要既能够被业务层理解，也能够被持久层理解。
**CTPersistanceTable**就封装了弱业务逻辑，由DataCenter调用，用于操作数据。而**Virtual Record**就是前面提到的一个既能够被业务层理解，也能够被持久层理解的数据载体。
Virtual Record事实上并不是一个对象，它只是一个protocol，这就是它Virtual的原因。一个对象只要实现了Virtual Record，它就可以直接被持久层当作Record进行操作，所以它也是一个Record。连起来就是Virtual Record了。所以，Virtual Record的实现者可以是任何对象，这个对象一般都是业务层对象。在业务层内，常见的数据表达方式一般都是View，所以一般来说Virutal Record的实现者也都会是一个View对象。
我们回顾一下传统的数据操作过程：**一般都是先从数据库中取出数据，然后Model化成一个对象，然后再把这个模型丢到外面，让Controller转化成View，然后再执行后面的操作**。
Virtual Record也是一样遵循类似的步骤。唯一不同的是，整个过程中，它并不需要一个中间对象去做数据表达，对于数据的不同表达方式，由各自Virtual Record的实现者自己完成，而不需要把这些代码放到Controller，所以这就是一个去Model化的设计。如果未来针对这个数据转化逻辑有复用的需求，直接复用Virtual Record就可以了，十分方便。
用好Virtual Record的关键在于DataCenter提供的接口对业务足够友好，有充足的业务上下文环境。
所以DataCenter一般都是被Controller所持有，所以如果整个App就只有一个DataCenter，这其实并不是一个好事。我见过有很多App的持久层就是一个全局单例，所有持久化业务都走这个单例，这是一种很蛋疼的做法。DataCenter也是需要针对业务做高度分化的，每个大业务都要提供一个DataCenter，然后挂在相关Controller下交给Controller去调度。比如分化成SettingsDataCenter，ChatRoomDataCenter，ProfileDataCenter等，另外要要注意的是，几个DataCenter之间最好不要有业务重叠。如果一个DataCenter的业务实在是大，那就再拆分成几个小业务。如果单个小业务都很大了，那就拆成各个Category，具体的做法可以参考我的框架中CTPersistanceTable和CTPersistanceQueryCommand的实践。
这么一来，如果要迁移涉及持久层的强业务，那就只需要迁移DataCenter即可。如果要迁移弱业务，就只需要迁移CTPersistanceTable。
### 实际场景
假设业务层此时收集到了用户的筛选条件：
![](assets/16790471868661.jpg)
然后ViewController调用DataCenter向业务层提供的接口，获得数据直接展示：
![](assets/16790472682800.jpg)
在View层要做的事情其实到这里就已经结束了，此时我们回过头再来看DataCenter如何实现这个业务：
![](assets/16790473275391.jpg)
一般来说，架构师设计得差的持久层，都没有**通过设计DataCenter和Table，去将强业务和弱业务分开**。通过设计DataCenter和Table对象，主要是便于代码迁移。如果迁移强业务，把DataCenter和Table一起拿走就可以，如果只是迁移弱业务，拿走Table就可以了。
另外，通过代码我希望向你强调一下这个概念：**将Table和Record区分开**，这个在我之前画的架构图上已经有所表现，不过上文并没有着重强调。其实很多别的架构师在设计持久层框架的时候，也没有将Table和Record区分开，对的，这里我说的框架包括Core Data和FMDB，这个也不仅限于iOS领域，CodeIgniter、ThinkPHP、Yii、Flask这些也都没有对这个做区分。
* 多对一场景下，业务层如何与持久层交互？
多对一场景其实有两种理解，一种是一个记录的数据由多个View的数据组成。例如一张用户表包含用户的所有资料。然后有的View只包含用户昵称用户头像，有的对象只包含用户ID用户Token。然而这些数据都只存在一张用户表中，所以这是一种多个对象的数据组成一个完整Record数据的场景，这是多对一场景的理解之一。
第二种理解是这样的，例如一个ViewA对象包含了一个Record的所有信息，然后另一个ViewB对象其实也包含了一个Record的所有信息，这就是一种多个不同对象表达了一个Record数据的场景，这也是一种多对一场景的理解。
同时，这里所谓的交互还分两个方向：存和取。
其实这两种理解的解决方案都是一样的，Virtual Record的实现者通过实现Merge操作来完成record数据的汇总，从而实现存操作。任意Virtual Record的实现者通过Merge操作，就可以将自己的数据交付给其它不同的对象进行表达，从而实现取操作。具体的实现在下面有具体阐释。
    * 多对一场景下，如何进行存操作？
    * 多对一场景下，如何进行存操作？
* 一对多场景下，业务层如何与持久层交互？
    * 一个对象包含了多个表的数据时，如何进行存取操作？
    * 一个对象用于展示多种表的数据，如何进行存取操作？
### 交互方案的总结
在交互方案的设计中，**架构师应当区分好强弱业务，把传统的Data Model区分成Table和Record，并由DataCenter去实现强业务，Table去实现弱业务**。在这里由于DataCenter是强业务相关，所以在实际编码中，业务工程师负责创建DataCenter，并向业务层提供业务友好的方法，然后再在DataCenter中操作Table来完成业务层交付的需求。区分强弱业务，将Table和Record拆分开的好处在于：
* 通过业务细分降低耦合度，使得代码迁移和维护非常方便
* 通过拆解数据处理逻辑和数据表达形态，使得代码具有非常良好的可拓展性
* 做到读写隔离，避免业务层的误操作引入Bug
* 为Virtual Record这一设计思路的实践提供基础，进而实现更灵活，对业务更加友好的架构

在具体与业务层交互时，**采用Virtual Record的设计思路来设计Record，由具体的业务对象来实现Virtual Record，并以它作为DataCenter和业务层之间的数据媒介进行交互**。而不是使用传统的数据模型来与业务层做交互。
使用Virtual Record的好处在于：
* 将数据适配和数据转化逻辑封装到具体的Record实现中，可以使得代码更加抽象简洁，代码污染更少
* 数据迁移时只需要迁移Virtual Record相关方法即可，非常容易拆分
* 业务工程师实现业务逻辑时，可以在不损失可维护性的前提下，极大提高业务实现的灵活性
## 数据迁移方案
## 数据同步方案